package io.m3.sql;

import static io.m3.sql.M3RepositoryException.Type.PREPARED_STATEMENT_SETTER;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.ImmutableList;

import io.m3.sql.builder.DeleteBuilder;
import io.m3.sql.builder.InsertBuilder;
import io.m3.sql.builder.SelectBuilder;
import io.m3.sql.builder.UpdateBuilder;
import io.m3.sql.desc.SqlColumn;
import io.m3.sql.desc.SqlPrimaryKey;
import io.m3.sql.desc.SqlSingleColumn;
import io.m3.sql.desc.SqlTable;
import io.m3.sql.domain.Page;
import io.m3.sql.domain.PageImpl;
import io.m3.sql.domain.Pageable;
import io.m3.sql.expression.AggregateFunction;
import io.m3.sql.id.SequenceGenerator4Long;
import io.m3.sql.jdbc.InsertMapper;
import io.m3.sql.jdbc.InsertMapperWithAutoIncrement;
import io.m3.sql.jdbc.M3PreparedStatementSetterException;
import io.m3.sql.jdbc.MapperException;
import io.m3.sql.jdbc.PreparedStatementSetter;
import io.m3.sql.jdbc.ResultSetMapper;
import io.m3.sql.jdbc.ResultSetMappers;
import io.m3.sql.jdbc.UpdateMapper;

/**
 * Repository pattern, subclasses will be generated by apt.
 *
 * @author <a href="mailto:jacques.militello@gmail.com">Jacques Militello</a>
 */
public abstract class Repository {

    private static final Logger LOGGER = LoggerFactory.getLogger(Repository.class);

    private final Database database;

    public Repository(Database database) {
        this.database = database;
    }

    protected Database database() {
        return this.database;
    }

    protected final SelectBuilder select(ImmutableList<SqlColumn> columns) {
        return new SelectBuilder(this.database, columns);
    }

    protected final SelectBuilder select(SqlColumn... columns) {
        return new SelectBuilder(this.database, ImmutableList.copyOf(columns));
    }

    protected final SelectBuilder select(AggregateFunction aggregateFunction) {
        return new SelectBuilder(this.database, aggregateFunction);
    }

    protected final InsertBuilder insert(SqlTable table, ImmutableList<SqlPrimaryKey> keys,
                                         ImmutableList<SqlSingleColumn> columns) {
        return new InsertBuilder(this.database, table, keys, columns);
    }

    protected final UpdateBuilder update(SqlTable table, ImmutableList<SqlSingleColumn> columns, ImmutableList<SqlPrimaryKey> keys) {
        return new UpdateBuilder(this.database, table, columns, keys);
    }

    protected final DeleteBuilder delete(SqlTable table) {
        return new DeleteBuilder(this.database, table);
    }

    protected final <T> T executeSelect(String sql, PreparedStatementSetter pss, ResultSetMapper<T> mapper) {
        PreparedStatement ps = database.transactionManager().current().read(sql);
        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3RepositoryException(PREPARED_STATEMENT_SETTER, sql, cause);
        }
        try (ResultSet rs = ps.executeQuery()) {
            if (rs.next()) {
                return mapper.map(this.database.dialect(), rs);
            } else {
                return null;
            }
        } catch (SQLException cause) {
            throw new M3SqlException("executeSelect: cannot retrieve or map resultset", cause);
        }

    }

    protected final <E> void executeBatchInsert(String sql, InsertMapper<E> im, List<E> pojos,
                                                SequenceGenerator4Long generator) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("INSERT : [{}], pojo=[{}]", sql, pojos);
        }

        PreparedStatement ps =  database.transactionManager().current().write(sql);
        for (E po : pojos) {
            try {
                im.insert(ps, po);
            } catch (SQLException cause) {
                throw new MapperException(sql, im, pojos, cause);
            }
            try {
                ps.addBatch();
            } catch (SQLException cause) {
                throw new MapperException(sql, im, pojos, cause);
            }

        }

        int[] vals;

        try {
            vals = ps.executeBatch();
        } catch (SQLException cause) {
            throw new M3SqlException("executeBatchInsert: cannot Insert", cause);
        }

        if (vals.length != pojos.size()) {
            throw new M3SqlException(
                    "executeBatchInsert: should update " + pojos.size() + " elements but updated " + vals.length);
        }
        for (int value : vals) {
            if (value == 0) {
                throw new M3SqlException("executeBatchInsert: failed to insert one or more records");
            }
        }

    }

    protected final <T> Stream<T> stream(String sql, PreparedStatementSetter pss, ResultSetMapper<T> mapper) {

        PreparedStatement ps = database.transactionManager().current().read(sql);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("stream : [{}]", sql);
        }

        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3PreparedStatementSetterException(sql, pss, cause);
        }

        ResultSet rs;
        try {
            rs = ps.executeQuery();
        } catch (SQLException cause) {
            throw new M3SqlException("executeSelect: cannot retrieve or map resultset", cause);
        }

        database.transactionManager().current().addHook(() -> {
            try {
                rs.close();
            } catch (SQLException cause) {
                LOGGER.warn("Hook -> failed to closed resultset for stream({})", sql);
            }
        });

        return StreamSupport.stream(new Spliterator<T>() {
            @Override
            public boolean tryAdvance(Consumer<? super T> action) {
                try {
                    if (!rs.next()) {
                        return false;
                    }
                } catch (SQLException e1) {
                    LOGGER.error("Error during resultSet.next() [{}]", sql);
                }
                try {
                    action.accept(mapper.map(database.dialect(), rs));
                } catch (SQLException e) {
                    LOGGER.error("Error during mapping from DB [{}]", e);
                }
                return true;
            }

            @Override
            public Spliterator<T> trySplit() {
                return null;
            }

            @Override
            public long estimateSize() {
                return 0;
            }

            @Override
            public int characteristics() {
                return 0;
            }
        }, false);

    }

    protected <E> void executeInsert(String sql, InsertMapper<E> im, E pojo) {
        PreparedStatement ps = database.transactionManager().current().write(sql);
        try {
            im.insert(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, im, pojo, cause);
        }
        int val;
        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new M3SqlException("executeInsert: cannot Insert", cause);
        }
        if (val != 1) {
            throw new M3SqlException("executeInsert: should update 1 element but updated [" + val + "]");
        }
    }

    protected <E> void executeUpdate(String sql, UpdateMapper<E> um, E pojo) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("UPDATE : [{}], pojo=[{}]", sql, pojo);
        }

        PreparedStatement ps = database.transactionManager().current().write(sql);

        try {
            um.update(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, um, pojo, cause);
        }

        int val;

        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new M3SqlException("executeUpdate: cannot executeUpdate", cause);
        }

        if (val != 1) {
            throw new M3SqlException("executeUpdate: should update 1 element but updated [" + val + "]");
        }

    }

    protected final <E> void executeInsertAutoIncrement(String sql, InsertMapperWithAutoIncrement<E> im, E pojo) {

        PreparedStatement ps = database.transactionManager().current().write(sql);

        try {
            im.insert(ps, pojo);
        } catch (SQLException cause) {
            throw new MapperException(sql, im, pojo, cause);
        }

        int val;
        try {
            val = ps.executeUpdate();
        } catch (SQLException cause) {
            throw new M3SqlException("executeInsert: cannot Insert", cause);
        }
        if (val != 1) {
            throw new M3SqlException("executeInsert: should update 1 element but updated [" + val + "]");
        }

        try (ResultSet rs = ps.getGeneratedKeys()) {
            if (rs.next()) {
                im.setId(pojo, rs);
            }
        } catch (SQLException cause) {
            throw new M3RepositoryException(M3RepositoryException.Type.INSERT_GENERATED_KEYS, "Failed to getGeneratedKeys", cause);
        }

    }

    protected final void executeDelete(String sql, PreparedStatementSetter pss) {

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("DELETE : [{}]", sql);
        }

        PreparedStatement ps = database.transactionManager().current().write(sql);

        try {
            pss.set(ps);
        } catch (SQLException cause) {
            throw new M3PreparedStatementSetterException(sql, pss, cause);
        }

        try {
            int val = ps.executeUpdate();

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("DELETE : number of element [{}]", val);
            }

        } catch (SQLException cause) {
            throw new M3SqlException("executeUpdate: cannot executeUpdate", cause);
        }

    }

    protected final <T> Page<T> executeSelectPage(String countSql, String sql, ResultSetMapper<T> mapper, Pageable pageable) {

        Long count = executeSelect(countSql, ps -> {

        }, ResultSetMappers.SINGLE_LONG);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("find count=[{}]", count);
        }

        if (count == null || count == 0) {
            return Page.empty();
        }

        return new PageImpl<>(stream(sql, ps -> {

        }, mapper), count, pageable);

    }

}
